#!/bin/bash
# combustion: network

# Redirect output to the console
exec > >(exec tee -a /dev/tty0) 2>&1

# Set hostname
echo "${VMNAME}" > /etc/hostname
hostname "${VMNAME}"

# SSH key management
if [ "${SSHCONFIG}" = true ]; then
	mkdir -pm700 /root/.ssh/
	echo "${SSHCONTENT}" >> /root/.ssh/authorized_keys
fi

# Registration
if [ "${REGISTER}" = true ]; then
	if ! which SUSEConnect > /dev/null 2>&1; then
		zypper --non-interactive install suseconnect-ng
	fi
	SUSEConnect --email "${EMAIL}" --url https://scc.suse.com --regcode "${REGCODE}"
fi

# Cockpit
if [ "${COCKPIT}" = true ]; then
	systemctl enable cockpit.socket
fi

# Podman
if [ "${PODMAN}" = true ]; then
	systemctl enable podman.service podman.socket
fi

# K3s
if [ "${K3S}" = true ]; then
	# Mount /usr/local to store the k3s script
	mount /usr/local || true
	# Stolen from https://code.opensuse.org/adathor/combustion-dotconf/blob/main/f/K3s%20cluster/k3s_master/script
	INSTALL_K3S_EXEC='server --cluster-init --write-kubeconfig-mode=644'
	# Download and install the latest k3s installer
	curl -L --output k3s_installer.sh https://get.k3s.io && install -m755 k3s_installer.sh /usr/local/bin/
	# Create a systemd unit that installs k3s if not installed yet. The k3s service is started after the installation
	cat <<- EOF > /etc/systemd/system/install-k3s.service
	[Unit]
	Description=Run K3s installer
	Wants=network-online.target
	After=network.target network-online.target
	ConditionPathExists=/usr/local/bin/k3s_installer.sh
	ConditionPathExists=!/usr/local/bin/k3s

	[Service]
	Type=forking
	TimeoutStartSec=120
	Environment="INSTALL_K3S_EXEC=$INSTALL_K3S_EXEC"
	Environment="INSTALL_K3S_VERSION=${K3s_VERSION}"
	ExecStart=/usr/local/bin/k3s_installer.sh
	RemainAfterExit=yes
	KillMode=process
	# Disable & delete everything
	ExecStartPost=/bin/sh -c "systemctl start k3s"
	ExecStartPost=rm -f /usr/local/bin/k3s_installer.sh
	ExecStartPost=/bin/sh -c "systemctl disable install-k3s"
	ExecStartPost=rm -f /etc/systemd/system/install-k3s.service
	
	[Install]
	WantedBy=multi-user.target
	EOF

	systemctl enable install-k3s.service
fi

# Rancher
if [ "${RANCHER}" = true ]; then
	# Mount /usr/local to store the rancher install script
	mount /usr/local || true

	# Download helm as required to install rancher
	curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 |bash

	# Create a script to install rancher that will be called via a systemd service
	cat <<- EOF > /usr/local/bin/rancher_installer.sh
	#!/bin/bash

	# Wait for k3s to be available
	until [ -f /etc/rancher/k3s/k3s.yaml ]; do sleep 2; done
	export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
	# Wait for the node to be available, meaning the K8s API is available
	while ! kubectl wait --for condition=ready node $(cat /etc/hostname | tr '[:upper:]' '[:lower:]') --timeout=60s; do sleep 2 ; done

	# https://ranchermanager.docs.rancher.com/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster
	helm repo add rancher-latest https://releases.rancher.com/server-charts/latest
	helm repo add jetstack https://charts.jetstack.io
	# Update your local Helm chart repository cache
	helm repo update

	# Install the cert-manager Helm chart
	helm install cert-manager jetstack/cert-manager \
	  --namespace cert-manager \
	  --create-namespace \
		--set installCRDs=true \
	  --version v1.11.1
	
	# Install rancher using sslip.io as hostname and with just a single replica
	helm install rancher rancher-latest/rancher \
  	--namespace cattle-system \
		--create-namespace \
  	--set hostname=$(hostname -I | awk '{print $1}').sslip.io \
  	--set bootstrapPassword=${RANCHERBOOTSTRAPPASSWORD} \
		--set replicas=1 \
		--set global.cattle.psp.enabled=false

	rm -f /etc/systemd/system/install-rancher.service
	EOF

	chmod a+x /usr/local/bin/rancher_installer.sh

	# Create a systemd unit to install rancher once
	# Using "User=root" is required for some environment variables to be present 
	cat <<- EOF > /etc/systemd/system/install-rancher.service
	[Unit]
	Description=Deploy Rancher on K3s
	Wants=network-online.target
	After=network.target network-online.target k3s.service
	ConditionPathExists=/usr/local/bin/rancher_installer.sh

	[Service]
	User=root
	Type=forking
	TimeoutStartSec=120
	ExecStart=/usr/local/bin/rancher_installer.sh
	RemainAfterExit=yes
	KillMode=process
	# Disable & delete everything
	ExecStartPost=rm -f /usr/local/bin/rancher_installer.sh
	ExecStartPost=/bin/sh -c "systemctl disable install-rancher.service"
	ExecStartPost=rm -f /etc/systemd/system/install-rancher.service

	[Install]
	WantedBy=multi-user.target
	EOF

	systemctl enable install-rancher.service
fi

# Bypass rancher bootstrap
if [ "${RANCHERBOOTSTRAPSKIP}" = true ]; then
	# Mount /usr/local to store the rancher bootstrap skip script
	mount /usr/local || true

	# Install jq
	zypper --non-interactive install jq

	# Create a script that will skip all the rancher bootstrap steps
	# See https://stackoverflow.com/a/61259844 for the reason about ${q} :)
	cat <<- "EOF" > /usr/local/bin/skip-rancher-bootstrap.sh
	#!/bin/bash
	HOST="https://$(hostname -I | awk '{print $1}').sslip.io"

	while ! kubectl wait --for condition=ready -n cattle-system $(kubectl get pods -n cattle-system -l app=rancher -o name) --timeout=10s; do sleep 2 ; done

	# Get token
	TOKEN=$(curl -sk -X POST $${q}HOST/v3-public/localProviders/local?action=login -H 'content-type: application/json' -d '{"username":"admin","password":"${RANCHERBOOTSTRAPPASSWORD}"}' | jq -r .token)

	# Set password
	curl -sk $${q}HOST/v3/users?action=changepassword -H 'content-type: application/json' -H "Authorization: Bearer $${q}TOKEN" -d '{"currentPassword":"${RANCHERBOOTSTRAPPASSWORD}","newPassword":"${RANCHERFINALPASSWORD}"}'

	# Get API token
	APITOKEN=$(curl -sk $${q}HOST/v3/token -H 'content-type: application/json' -H "Authorization: Bearer $${q}TOKEN" -d '{"type":"token","description":"automation"}' | jq -r .token)

	curl -sk $${q}HOST/v3/settings/server-url -H 'content-type: application/json' -H "Authorization: Bearer $${q}APITOKEN" -X PUT -d "{\"name\":\"server-url\",\"value\":\"$${q}HOST\"}"
	curl -sk $${q}HOST/v3/settings/telemetry-opt -X PUT -H 'content-type: application/json' -H 'accept: application/json' -H "Authorization: Bearer $${q}APITOKEN" -d '{"value":"out"}'
	EOF

	chmod a+x /usr/local/bin/skip-rancher-bootstrap.sh

	# Create a systemd unit to run the steps after rancher has been installed
	# Using "User=root" is required for some environment variables to be present 
	cat <<- EOF > /etc/systemd/system/skip-rancher-bootstrap.service
	[Unit]
	Description=Skip Rancher Bootstrap
	Wants=network-online.target
	After=network.target network-online.target install-rancher.service
	ConditionPathExists=/usr/local/bin/skip-rancher-bootstrap.sh

	[Service]
	User=root
	Type=forking
	TimeoutStartSec=120
	ExecStart=/usr/local/bin/skip-rancher-bootstrap.sh
	RemainAfterExit=yes
	KillMode=process
	# Disable & delete everything
	ExecStartPost=rm -f /usr/local/bin/skip-rancher-bootstrap.sh
	ExecStartPost=/bin/sh -c "systemctl disable skip-rancher-bootstrap.service"
	ExecStartPost=rm -f /etc/systemd/system/skip-rancher-bootstrap.service

	[Install]
	WantedBy=multi-user.target
	EOF

	systemctl enable skip-rancher-bootstrap.service
fi

# Update and reboot as required by transactional-update
if [ "${UPDATEANDREBOOT}" = true ]; then
	cat <<- EOF > /etc/systemd/system/update-and-reboot.service
	[Unit]
	Description=Reboot if required once
	Wants=network-online.target
	After=network.target network-online.target install-rancher.service
	[Service]
	User=root
	# Run this service the last one
	Type=oneshot
	ExecStart=transactional-update
	ExecStartPost=/bin/sh -c "systemctl disable update-and-reboot.service"
	ExecStartPost=rm -f /etc/systemd/system/update-and-reboot.service
	ExecStartPost=reboot
	RemainAfterExit=yes
	# Long timeout just in case
	TimeoutSec=3600
	[Install]
	WantedBy=multi-user.target
	EOF
	systemctl enable update-and-reboot.service
fi

# Leave a marker
echo "Configured with combustion" >> /etc/issue.d/combustion
